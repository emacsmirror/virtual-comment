#+startup:    content indent

* overview, design
because parsing the text file is tedious store in elisp format and have a
special mode to read it and show it in a buffer.

persistent file is project based or global

must have something like project based management mechanism to share 

such as tide.

when a buffer with icl mode on started up it will locate its project root which resolves
to global or project root. The project root is now a unique key to indentify the comment store

there is a global comment store which is a map of project  root -> project comment store

project comment store:
- comments: (file (line . comment)...)
- count: number of active buffers reading this store, when is is down to zero comments will be set to nil
- hook: this hook runs on store changed

** use case:
in project A, buffer a starts up and gets its project unique key as A,
From the global comment stores it gets it project comment store.
It is nil and the count is now set to 0.
With the count value it knows that it is the first one to access this store. 
It updates the count to one and initializes comments value for project.
Then it reads the comments from the store and show the comments in buffers.

Next a buffer b in project A starts up, and follows the same procedure but the
count is already greater than 0 so it means the project comment store is
already set up to go. So buffer b will just use the store and increase the count.

Some time later buffer b closes, it will decrease the count. It check the count
is still greater than 0

And finally buffer a is about to close. After decreasing the count to 0, that
means it is the last consumer of the store so it set the comment variable to
nil. Persist the data to a .ilc file

No memory leak this way.
** occur mode add marker info to text 
(get-text-property (point) 'occur-target)

use propertize to make string
* DONE test setup
CLOSED: [2020-12-05 Sat 11:44]
cask install
cask exec ert-runner

* data stucture for project
hash table
project: file -> comments { line: comment } 
#+begin_src elisp
((#<overlay from 8503 to 8503 in ipa.el> .
            #("need to forward-char here" 0 25
              (fontified nil)))
 (#<overlay from 22765 to 22765 in ipa.el> .
            #("use project
multiple line really" 0 11
(fontified nil)
12 32
(fontified nil)))
 (#<overlay from 23192 to 23192 in ipa.el> .
            #("take care of project option" 0 27
              (fontified nil))))
#+end_src

https://github.com/sigma/pcache

* overlay structure
(overlay-put (make-overlay (point) (point) (current-buffer)) 'before-string "crap")

(overlay-put (make-overlay (point) (point) (current-buffer)) 'before-string "crap")
* problem with overlay moving
if only data structure is kept i.e line number and string
then when overlay is moved because of buffer change then we lose track of overlay

overlay should stick to the line it belongs to, eg symbol-overlay

in buffer 

we don't manage the ov list anymore sorting it keep it in order is a headache
just grab all the overlays in the buffer which has the tag then this is it.

https://www.gnu.org/software/emacs/manual/html_node/elisp/Finding-Overlays.html

for next and previous
next-overlay-change pos
previous-overlay-change pos
* TODO merge comments when the lines they are on are joined into one line
* DONE next and previous comment
* DONE indentation comment
how to extract and make/separate comment from indentation
the real string stored in 'virtual-comment tag
'before-string is to store the presentational text
* handle comment when its line moves is a big headache
there is a hook but it won't get triggered on some occasions so we won't handle
it. instead we provide functions to repair, copy and paste comment

yank, paste
* data layer
** function that grabs all the current overlays in buffer
** function that takes overlays list and produces comment data structure

read-from-string is a built-in function in ‘C source code’.

(read-from-string STRING &optional START END)

Read one Lisp expression which is represented as text by STRING.
Returns a cons: (OBJECT-READ . FINAL-STRING-INDEX).
FINAL-STRING-INDEX is an integer giving the position of the next
remaining character in STRING.  START and END optionally delimit
a substring of STRING from which to read;  they default to 0 and
(length STRING) respectively.  Negative values are counted from
the end of STRING.
** dump dat to file and load
it's a experiment
* repair should take into account of indentation beside point-at-bol
* unused sorting
#+begin_src elisp
(defun virtual-comment-buffer-overlays--add (ov my-list)
  "MY-LIST has at least one element and its head is smaller than OV."
  (let ((start (overlay-start ov))
        (head (car my-list))
        (tail (cdr my-list)))
    (if (or (not tail)
            (<= start (overlay-start (car tail))))
        (setcdr my-list (cons ov tail))
      (virtual-comment-buffer-overlays--add ov tail))))

(defun virtual-comment-buffer-overlays-add (ov)
  "Add OV to `virtual-comment-buffer-overlays' in order."
  (if (or (not virtual-comment-buffer-overlays)
          (< (overlay-start ov) (overlay-start (car virtual-comment-buffer-overlays))))
      (push ov virtual-comment-buffer-overlays)
    (virtual-comment-buffer-overlays--add ov virtual-comment-buffer-overlays)))

#+end_src
